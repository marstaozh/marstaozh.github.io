## 1. 考试大纲

```
1. 数据库模型(概念模式、外模式、内模式)
2. 数据模型，ER图，第一范式，第二范式，第三范式
3. 数据操作(集合运算和关系运算)
4. 数据库语言
5. 数据库的控制功能
6. 数据仓库和分布式数据库基础知识
```



## 2. 考点

```
1. ER模型
2. 键码、函数依赖、范式
3. 关系代数、元组演算
4. SQL语言
```



## 3. ER模型

### 3.1 ER模型的基础

```
1. ER模型的基本概念
	1.1 实体Entity：
			是指客观存在可以互相区别的事物。
			实体型用矩形表示
	1.2 属性Attribute：
			实体有多特性，每个特性称为属性。
			属性使用椭圆形表示
	1.3 联系Relationship：
			1对1联系、1对多联系、多对多联系
			联系使用菱形表示

2. 如何绘制ER图
	2.1 确定实体类
	2.2 确定联系类型，确定联系的属性
	2.3 把实体类型和联系类型组合成ER图
	2.4 确定实体类型和联系类型的属性
	2.5 确定实体类型的主键，在主键的属性名下划一横线
```



### 3.2 ER模型的转换规则

```
1. ER模型转换成关系模型的规则
	1.1 一个实体型转换为一个关系模式，实体的属性就是关系的属性，实体的码就是关系的码。
	1.2 一个1对1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。
		如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码。
		如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。
	1.3 1对多联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。
		如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码。
	1.4 多对多联系转换为一个关系模式。与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的吗为各实体码的组合
	1.5 三个或以上实体间的多元联系可以转换为一个关系模式。与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性。而关系的码为各实体码的组合。
```



## 4. 键码、函数依赖、范式

### 4.1 键码

```
1. 超键：
	在关系模式中，能唯一标识元组的属性集称为超键。
2. 候选键：
	在关系模式中，能唯一标识元组，并且不包含多余属性的属性集称为候选键。
3. 主键：
	在一个关系的若干个候选键中随意指定一个作为主键。
4. 外键：
	关系模式R1中的某属性集不是R1的候选键，而是关系模式R2的候选键，则这个属性集是模式R1外键。
5. 主属性：
	候选码中的主属性称为主属性。
6. 非主属性：
	不包含在任何候选码中的属性称为非主属性。
```

> 如何区分超键、候选键和主键？
>
> * 从区分实体功能来说，这三种键的作用是一样的。
> * 超键中可能有无关属性，而主键和候选键中属性都是必要的属性。
> * 主键和候选键的区别在于主键是被选中的。主键是候选键中的一个。



### 4.2 函数依赖

> 设R(U)是属性集U上的关系模式。 X，Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y 或 Y函数依赖于X，记作X->Y

```
1. 完全函数依赖
	在R(U)中，如果X->Y, 并且对于X的任何一个真子集X'，都有X' -\-> Y, 则称Y对X完全函数依赖，记作 X -F-> Y

2. 若X -> Y, 但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作 X -P-> Y

3. 在R(U)中，如果X->Y, (Y ∉ X), Y -\-> X, Y->Z, 则称Z对X传递函数依赖。
```



### 4.3 范式

```
1. 1NF
	在关系模式R中，当且仅当所有域只包含原子值，即每个分量都是不可再分的数据项，则称实体E是1NF
	
2. 2NF
	当且仅当实体E是1NF，且每一个非键属性【完全依赖】主键（没有不完全依赖）时，则称实体E为2NF 

3. 3NF
	当且仅当实体E是2NF，切E中没有非主属性【传递依赖】于码时，则称实体E为3NF
```



### 4.4 无损联接分解

> 是指将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式，称这种分解为无损联接分解

```
1. 无损：可以还原
2. 有损：不能还原
```



## 5. 关系代数及元组演算

### 5.1 关系代数基本运算

```
1. 并(∪)：计算两个表在集合理论上的联合

2. 差(-)：计算两个表的区别的集合

3. 笛卡尔积(×)：计算两个关系的笛卡尔乘积。
	R有k1元的表，S有k2元的表。R×S是使用R表中每条k1元分别与S表中的每条k2元记录拼接后的集合。
	RxS的结果集记录 = k1记录数 * k2记录数。
	
4. 投影(π)：从一个关系里面抽取知名的属性。
	令R为一个包含一个属性X的关系，πX(R) = {t(X) | t∈R}，这里t(X)表示记录t里的属性X的值。

5. 选择(σ)：从关系里面抽取出满足给定限制条件的记录。
	令R为一个表，包含一个属性A，σA=a(R)={t∈R | t(A)=a}
	这里t表示R的一条记录，而t(A)表示记录t的属性A的值。
	
6. 交(∩)：计算两个表集合理论上的交集。给出表R和S，R∩S是同时在R和S里面的记录的集合。要求R和S拥有相同的元/列数。

7. 联接(▷◁)：通过共同属性联接两个表。
	令R为一个有属性A，B，C的表，令S为一个有C，D，E的表。两个表有一个共同属性C
	R▷◁S = π(R.A,R.B,R.C,S.D,S.E)(σR.C=S.C(R×S))
	这个式子中，首选计算笛卡尔积R×S，然后选择公共属性C的数值相同（σR.C=S.C）的字段。
	此时的集合是一个包含属性C两次的表，把重复的列通过投影(π)去掉后即可得到联接的结果。

8. 除(÷)：设有关系R(X, Y)与关系S(Z)，其中X，Y，Z为属性集合。
	假设Y和Z具有相同的属性个数，且对应属性出自相同域。
	关系R(X, Y)÷S(Z)所得的商关系是关系R在属性X上投影的一个子集，
	该子集和S(Z)的笛卡尔积必须包含在R(X,Y)中，记为R÷S
```

| 关系R | A    | B    | C    | D    | 关系S | C    | D    |
| ----- | ---- | ---- | ---- | ---- | ----- | ---- | ---- |
|       | a    | b    | c    | d    |       | c    | d    |
|       | a    | b    | e    | f    |       | e    | f    |
|       | c    | a    | c    | d    |       |      |      |



### 5.2 关系代数的除法运算



### 5.3 元组演算

> 在元组关系演算系统中，称{t | Φ(t)} 为元组演算表达式。
>
> 其中，t是元组变量， Φ(t)是元组关系演算公式，简称公式。

* 原子公式

```
1. R(t)
	R是关系名，t是元组变量，R(t)表示t是R中的元组，可表示为{t | R(t)}
2. t[i] θ u[j]
	t,u是元组变量，θ是算术比较运算符（>, <, =）
	t[i] θ u[j]表示命题“元组t的第i个分量与元组u的第j个分量满足比较关系θ”
3. t[i] θ c 或 c θ t[i]
	这里c是常量，该公式表示“元组t的第i个分量与常量c满足比较关系θ”
```

* 公式的递归定义

```
1. 每个原子公式都是公式
2. 如果Φ1和Φ2是公式，则Φ1 ∧ Φ2， Φ1 ∨ Φ2， ¬Φ1都是公式。
	2.1 Φ1 ∧ Φ2表示两个公式结果的逻辑与，两者同时为真，结果才为真，否则为假。
	2.2 Φ1 ∨ Φ2表示两个公式结果的逻辑或，两者同时为假，结果才为假，否则为真。
	2.3 ¬Φ1表示非运算，Φ1为真，则¬Φ1为假。
3. 若Φ是公式，则 ∃t(Φ)也是公式。
	其中 ∃是存在量词符号，∃t(Φ)表示：存在一个元组t，是Φ为真，则 ∃t(Φ)为真，否则为假。
4. 若Φ是公式，则∀t(Φ)也是公式。
	其中符号∀是全称量词符号，∀t(Φ)表示：所有t都是Φ为真，则∀t(Φ)为真，否则为假。
5. 元组演算公式中，各种运算符的优先次序：
	5.1 算术比较运算符最高
	5.2 量词次之，且∃的优先级高于∀
	5.3 逻辑运算符最低，且 ¬ 的优先级高于 ∧的优先级， ∧的优先级高于 ∨的优先级
	5.4 可使用括号，括号内运算符优先，同一括号内的运算符优先级遵循以上三点。
6. 有限次地使用上述五条规则得到的公式是元组关系演算公式，其他公式不是元组关系演算公式。

说明：一个元组演算表达式{t | Φ(t)}表示使Φ(t)为真的元组
```

* 关系演算表达式表示五中基本运算

```
1. 并(∪)：R∪S = {t | R(t) ∨ S(t)}
2. 差(-)：R-S = {t | R(t) ∧ ¬S(t)}
3. 笛卡尔积(×)：
	R × S = {t^(n+m) | (∃u^(n))(∃v^(m))(R(u)∧S(v)∧t[1]=u[1]∧...∧t[n]=u[n]∧t[n+1]=u[1]∧...∧t[n+m]=u[m])}
4. 投影(π)：
	
5. 选择(σ)：
	σF(R) = {t | R(t) ∧ F'}
```



## 6. SQL语言





























