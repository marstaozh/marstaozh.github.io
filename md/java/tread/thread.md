# 1. 什么是多线程

## 1.1 进程的介绍

进程的定义：

> 进程是程序的⼀次执⾏，进程是⼀个程序及其数据在处理机上顺序执⾏时所发⽣的活动，进程是具有独⽴功能的程序在⼀个数据集合上运⾏的过程，它是系统进⾏资源分配和调度的⼀个独⽴单位。

> 进程是系统进⾏资源分配和调度的独⽴单位。每⼀个进程都有它⾃⼰的内存空间和系统资源。



## 1.2 回到线程

那系统有了进程这么⼀个概念了，进程已经是可以进⾏资源分配和调度了，为什么还要线程呢？
为使程序能并发执⾏，系统必须进⾏以下的⼀系列操作：

* 创建进程：系统在创建⼀个进程时，必须为它分配其所必需的、除处理机以外的所有资源，如
  内存空间、I/O设备，以及建⽴相应的PCB；
* 撤消进程：系统在撤消进程时，⼜必须先对其所占有的资源执⾏回收操作，然后再撤消PCB；
* 进程切换：对进程进⾏上下⽂切换时，需要保留当前进程的CPU环境，设置新选中进程的CPU
  环境，因⽽须花费不少的处理机时间。



从上操作可以看到进程实现多处理机环境下的**进程调度，分派，切换**时，都需要花费较⼤的时间和空间开销。
引⼊线程主要是为了提⾼系统的执⾏效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理。使OS具有更好的并发性

简单来说：**进程实现多处理⾮常耗费CPU的资源**，⽽我们引⼊线程是作为调度和分派的基本单位
（取代进程的部分基本功能【调度】）。

在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务就可以看作是⼀个线程。⼀个进程会有1个或多个线程的！



## 1.3 进程和线程的总结

* 总结

  > 进程：作为资源【分配】的基本单位
  >
  > 线程：作为资源【调度】的基本单位，是程序的执⾏单元，执⾏路径(单线程：⼀条执⾏路径，多线程：多条执⾏路径)。是程序使⽤CPU的最基本单位。

* 线程有3个基本状态：

  >执⾏、就绪、阻塞

* 线程有5种基本操作：

  >派⽣、阻塞、激活、 调度、 结束

* 线程的属性：

  > 轻型实体、独⽴调度和分派的基本单位、可并发执⾏、共享进程资源

* 线程有两个基本类型：

  > ⽤户级线程：管理过程全部由⽤户程序完成，操作系统内核⼼只对进程进⾏管理。
  > 系统级线程(核⼼级线程)：由操作系统内核进⾏管理。操作系统内核给应⽤程序提供相应的系统调⽤和应⽤程序接⼝API，以使⽤户程序可以创建、执⾏以及撤消线程。

* 值得注意的是：

  > 多线程的存在，不是提⾼程序的执⾏速度。其实是为了提⾼应⽤程序的使⽤率，程序的执⾏其实都是在抢CPU的资源，CPU的执⾏权。多个进程是在抢这个资源，⽽其中的某⼀个进程如果执⾏路径⽐较多，就会有更⾼的⼏率抢到CPU的执⾏权。



## 1.4 并行和并发

* 并⾏：

  > 并⾏性是指同⼀时刻内发⽣两个或多个事件。
  > 并⾏是在不同实体上的多个事件

* 并发：

  > 并发性是指同⼀时间间隔内发⽣两个或多个事件。
  > 并发是在同⼀实体上的多个事件

由此可⻅：并⾏是针对进程的，并发是针对线程的。



## 1.5 Java实现多线程

* 创建多线程有三种⽅法：

  > 继承Thread，重写run⽅法
  > 实现Runnable接⼝，重写run⽅法
  > 实现Callable接⼝，重写run⽅法

* 继承Thread，重写run⽅法

```java
public class MyThread extends Thread {
    @Override
    public void run() {
		for (int x = 0; x < 100; x++) {
			System.out.println(Thread.currentThread().getName() + x);
		}
	}
}
```

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        // 创建两个线程对象
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();
        my1.start();
        my2.start();
    }
}
```



* 实现Runnable接⼝，重写run⽅法

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int x = 0; x < 100; x++) {
        	System.out.println(Thread.currentThread().getName() + x);
        }
    }
}
```

```java
public class MyRunnableDemo {
    public static void main(String[] args) {
        // 创建MyRunnable类的对象
        MyRunnable my = new MyRunnable();
        Thread t1 = new Thread(my);
        Thread t2 = new Thread(my);
        t1.start();
        t2.start();
    }
}
```



* 实现Callable接⼝，重写run⽅法

```
实现Callable和实现Runnable类似，但是功能更强大，具体表现在
1. 可以在任务结束后提供一个返回值，Runnable不行
2. call方法可以抛出异常，Runnable的run方法不行
3. 可以通过运行Callable得到的Fulture对象监听目标线程调用call方法的结果，
	得到返回值，（fulture.get(),调用后会阻塞，直到获取到返回值）
```



* Java实现多线程需要注意的细节

  > run()和start()⽅法区别：
  > 	run() :仅仅是封装被线程执⾏的代码，直接调⽤是普通⽅法
  > 	start() :⾸先启动了线程，然后再由jvm去调⽤该线程的run()⽅法。

* jvm虚拟机的启动是单线程的还是多线程的?

  是多线程的。不仅仅是启动main线程，还⾄少会启动垃圾回收线程的。



# 2. Thread类解析

* 设置线程名

* 守护线程

>守护线程是为其他线程服务的
>
>* 圾回收线程就是守护线程

* 守护线程的特点

> 当别的用户线程执行完了，虚拟机就会退出，守护线程也就会被停止掉。守护线程作为一个服务线程，没有服务对象时就没有必要继续运行了。

* 使⽤线程的时候要注意的地⽅

>1. 在线程启动前设置为守护线程，⽅法是 setDaemon(boolean on)
>2. 使⽤守护线程不要访问共享资源(数据库、⽂件等)，因为它可能会在任何时候就挂掉了。
>3. 守护线程中产⽣的新线程也是守护线程

* 线程优先级

>线程优先级⾼仅仅表示线程获取的CPU时间⽚的⼏率⾼，但这不是⼀个确定的因素！
>
>线程的优先级是⾼度依赖于操作系统的, 
>
>Java提供的优先级默认是5，最低是1，最⾼是10

* 线程⽣命周期

> 线程有3个基本状态：执⾏、就绪、阻塞

```
线程生命周期相关的方法:
1. sleep
	进⼊计时等待状态, 等时间到了, 进⼊的是就绪状态⽽并⾮是运⾏状态
2. yield
	先让别的线程执⾏, 但是不确保真正让出
3. join
	等待该线程执⾏完毕后才执⾏别的线程
4. interrupt
	interrupt不会真正停⽌⼀个线程, 它仅仅是给这个线程发了⼀个信号告诉它, 它应该要结束了
	实际上是想线程⾃⼰来终⽌, 通过上⾯的信号, 就可以判断处理什么业务了
	具体到底中断还是继续运⾏, 应该由被通知的线程⾃⼰处理
```







# 3. 使用多线程需注意的问题



# 4. synchronized锁和lock锁



# 5. AQS



# 6. ReentrantLock和ReentrantReadWriteLock


# 7. 线程池



# 8. 死锁



# 9. 线程常用的工具类



# 10. Atomic



# 11. ThreadLocal

